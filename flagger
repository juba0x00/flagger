#!/usr/bin/env python3
from os import popen, path, mkdir
from argparse import ArgumentParser
from colorama import Fore
from base64 import b16encode, b16decode, b32encode, b32decode, b64encode, b64decode, b85encode, b85decode
from re import search
from threading import Thread

letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
           'w', 'x', 'y', 'z']

encoded_color = Fore.BLUE
flag_color = Fore.GREEN


def parse_arguments():
    parser = ArgumentParser(description='Search for the flag in strings output')
    parser.add_argument('-f', '--flag-format', help='Specify beginning of flag format (Ex: TUCTF)')
    parser.add_argument('-n', '--file-name', help='Specify the file name')
    parser.add_argument('-d', '--debug', action='store_true', help='Don\'t ask for inputs and Auto fill them')  # this option is used to make the testing easier
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose mode')
    parser.add_argument('-nr', '--no-rot', action='store_true', help='Disable rotation')
    return parser.parse_args()


def check_plain_flag(data):
    for line in data:
        if flag_format in line:
            print(f"{flag_color}{line}{Fore.RESET}")


def check_base16_flag(data):
    base16_flag = b16encode(flag_format.encode('ascii')).decode('ascii')
    for line in data:
        if base16_flag in line:
            print("{enc_color}{enc_line} -> {dec_color}{dec_line}{rst}".format(enc_color=encoded_color, enc_line=line,
                                                                               dec_color=flag_color,
                                                                               dec_line=b16decode(line.upper()).decode('ascii').replace('\n', ''),
                                                                               rst=Fore.RESET))
            # .upper() to avoid hexdecimal decoding errors (ABC..., instead of abc..ABC..., instead of abc....)


def check_base32_flag(data):
    base32_flag = b32encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base32_flag = base32_flag[:len(base32_flag) - 1]  # to avoid the last digit unmatching
    for line in data:
        if line.startswith(base32_flag):
            print(f"{encoded_color}{line} -> {flag_color}{b32decode(line.encode('ascii')).decode('ascii')}{Fore.RESET}")


def check_base64_flag(data):
    base64_flag = b64encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base64_flag = base64_flag[:len(base64_flag)-1]  # to avoid the last digit unmatching
    for line in data:
        if base64_flag in line:
            print(f"{encoded_color}{line} -> {flag_color}{b64decode(line.encode('ascii')).decode('ascii')}{Fore.RESET}")


def check_base85_flag(data):
    base85_flag = b85encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base85_flag = base85_flag[:len(base85_flag)-1]  # to avoid the last digit unmatching
    for line in data:
        if line.startswith(base85_flag):
            print(f"{encoded_color}{line} -> {flag_color}{b85decode(line.encode('ascii')).decode('ascii')}{Fore.RESET}")


def check_binary_flag(data):
    for line in data:
        try:
            bint = int(line, 2)  # binary int
            bnumber = bint.bit_length() + 7 // 8
            barry = bint.to_bytes(bnumber, "big")
            text = barry.decode()

            if flag_format in text:
                print(f"{encoded_color}{line} -> {flag_color}{text}{Fore.RESET}")
        except ValueError as e:
            # print(e)
            pass


def rotator(string, roter):
    rotated = []

    def rotx(number, x):
        while True:
            find = number + roter
            try:
                replace = find - 26*x
                rotated.append(letters[replace])
                break
            except:
                x = x + 1
    rotable = list(string.lower())
    for char in rotable:
        match = search(r'[a-z]', char)
        if match:
            number = 0
            for replace in letters:
                    if char == replace:
                        x = 1
                        rotx(number, x)
                        break
                    else:
                        number = number + 1
        else:
            rotated.append(char)

    string = ''.join(rotated)
    with open(f'{file_name}_rotates/rot{roter}', 'w') as saving_file:
        saving_file.write(string)

    rotated_lines = string.split('\n')
    for line in rotated_lines:
        if flag_format.lower() in line:
            print(f"{encoded_color}ROT{roter}: {flag_color}{line}{Fore.RESET}")

    for check_func in check_functions:
        if check_func is check_binary_flag:  # avoid checking the binary (rotation does not change it)
            continue
        try:
            check_func(rotated_lines[:])
        except ValueError:
            pass


def rotate():
    if not path.exists(f'{file_name}_rotates'):
        mkdir(f'{file_name}_rotates')

    # rotate and check after rotation
    for rot in range(1, 26):
        rotator(strings_output[:], rot)
    print(f'check {file_name}_rotates directory')


def shift(text, shifts):
    shifted_back = ""
    shifted_forward = ""
    for line in text: 
        if line == "": 
            # skip empty lines
            continue
        for char in line:
            try: # avoid out of range code
                shifted_back += chr(ord(char)-shifts)
            except ValueError:
                pass 
                
            shifted_forward += chr(ord(char)+shifts)
        if flag_format in shifted_back:
            print(f"{encoded_color}{line} -> {flag_color}{shifted_back}{Fore.RESET}")
            pass
        elif flag_format in shifted_forward:
            print(f"{encoded_color}{line} -> {flag_color}{shifted_forward}{Fore.RESET}")
        shifted_back = ""
        shifted_forward = ""


if __name__ == '__main__':
    args = parse_arguments()
    if args.debug:
        file_name = 'image.png'
        flag_format = 'TUCTF'
    else:
        file_name = args.file_name
        flag_format = args.flag_format

    strings_output = popen(f'strings "{file_name}" | sort | uniq').read()
    print(strings_output) if args.verbose else None
    lines = strings_output.split('\n')

    check_functions = [check_plain_flag,
                       check_binary_flag,
                       check_base16_flag,
                       check_base32_flag,
                       check_base64_flag,
                       check_base85_flag
                       ]

    for check in check_functions:
        Thread(target=check, args=[lines[:]]).start()

    Thread(target=rotate).start() if not args.no_rot else None

    for shifts in range(2, 26):
        Thread(target=shift, args=[lines[:], shifts]).start() if not args.no_rot else None
