#!/usr/bin/env python3
from os import popen, path, mkdir
from argparse import ArgumentParser
from colorama import Fore
from base64 import b16encode, b16decode, b32encode, b32decode, b64encode, b64decode, b85encode, b85decode
from base45 import b45encode, b45decode
from re import search, findall
from threading import Thread
from requests import get 
import oct

alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
           'w', 'x', 'y', 'z']

encoded_color = Fore.BLUE
flag_color = Fore.GREEN

def echo(encoded_flag, decoded_flag):
    """
    Print colored encoded and decoded flag 
    """
    print(f"{encoded_color}{encoded_flag} -> {flag_color}{decoded_flag}{Fore.RESET}")


def parse_arguments():
    parser = ArgumentParser(description='Search for the flag in strings output')
    parser.add_argument('-f', '--flag-format', help='Specify beginning of flag format (Ex: TUCTF)')
    parser.add_argument('-n', '--file-name', help='Specify the file name')
    parser.add_argument('-d', '--debug', action='store_true',
                        help='Don\'t ask for inputs and Auto fill them')  # this option is used to make the testing easier
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose mode')
    parser.add_argument('-nr', '--no-rot', action='store_true', help='Disable rotation')
    return parser.parse_args()


def check_plain_flag(data):
    for line in data:
        if flag_format in line:
            print(f"{flag_color}{line}{Fore.RESET}")


def check_base16_flag(data):
    base16_flag = b16encode(flag_format.encode('ascii')).decode('ascii')
    for line in data:
        if base16_flag in line:
            echo(encoded_flag=line, decoded_flag=b16decode(line.upper()).decode('ascii').replace('\n', ''))
            # .upper() to avoid hexdecimal decoding errors (ABC..., instead of abc..ABC..., instead of abc....)


def check_base32_flag(data):
    base32_flag = b32encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base32_flag = base32_flag[:len(base32_flag) - 1]  # to avoid the last digit unmatching
    for line in data:
        if line.startswith(base32_flag):
            echo(line, b32decode(line.encode('ascii')).decode('ascii'))


def check_base45_flag(data):
    base45_flag = b45encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base45_flag = base45_flag[:len(base45_flag) - 2]  # to avoid the last digit unmatching
    for line in data:
        if line.startswith(base45_flag):
            echo(line, b45decode(line.encode('ascii')).decode('ascii'))


def check_base64_flag(data):
    base64_flag = b64encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base64_flag = base64_flag[:len(base64_flag) - 1]  # to avoid the last digit unmatching
    for line in data:
        if base64_flag in line:
            echo(line, b64decode(line.encode('ascii')).decode('ascii'))


def check_base85_flag(data):
    base85_flag = b85encode(flag_format.encode('ascii')).decode('ascii').replace('=', '')
    base85_flag = base85_flag[:len(base85_flag) - 1]  # to avoid the last digit unmatching
    for line in data:
        if line.startswith(base85_flag):
            echo(line, b85decode(line.encode('ascii')).decode('ascii'))

def check_base8_flag(data):
    base8_flag = oct.oct_encode(flag_format)
    for line in data:
        if line.startswith(base8_flag):
            print(f"{encoded_color}{line} -> {flag_color}{oct.oct_decode(line)}{Fore.RESET}")
                      
def check_binary_flag(data):
    for line in data:
        try:
            bint = int(line, 2)  # binary int
            bnumber = bint.bit_length() + 7 // 8
            barry = bint.to_bytes(bnumber, "big")
            text = barry.decode()

            if flag_format in text:
                echo(line, text)
        except ValueError:
            pass

def rotator(cipher_text, key):
    rotated = []
    shifted_alphabet = [''] * len(alphabet)

    #fill shifted_alphabet
    for i in range(key, len(alphabet)):
        shifted_alphabet[i-key] = alphabet[i]

    shifted_alphabet[len(alphabet)-(key):] = alphabet[:key]

    #substitution
    deciphered = [''] * len(cipher_text)
    exists = False

    for i in range(len(cipher_text)):
        for j in range(len(shifted_alphabet)):
            if cipher_text[i].casefold() == shifted_alphabet[j].casefold():
                deciphered[i] = alphabet[j]
                exists = True
                break
            else:
                exists = False

            if not exists:
                deciphered[i] = cipher_text[i]

    #put the result in a string
    result = ''
    for i in range(len(deciphered)):
        result = result + deciphered[i]
    
    rotated.append(result)

    string = ''.join(rotated)
    with open(f'{file_name}_rotates/rot{roter}', 'w') as saving_file:
        saving_file.write(string)

    rotated_lines = string.split('\n')
    for line in rotated_lines:
        if flag_format.lower() in line:
            echo(f"ROT{roter}", line)

    for check_func in check_functions:
        if check_func is check_binary_flag:  # avoid checking the binary (rotation does not change it)
            continue
        try:
            check_func(rotated_lines[:])
        except ValueError:
            pass

def rotate():
    if not path.exists(f'{file_name}_rotates'):
        mkdir(f'{file_name}_rotates')

    # rotate and check after rotation
    for rot in range(1, 26):
        rotator(strings_output[:], rot)
    print(f'check {file_name}_rotates directory')

    #merge (concatenate) rotated files
    system(f'cat ./{file_name}_rotates/* > {file_name}_rotates/merged.txt')
    print(f'check {file_name}_rotates directory')
           
def shift(text, shifts):
    shifted_back = ""
    shifted_forward = ""
    for line in text:
        if line == "":
            # skip empty lines
            continue
        for char in line:
            try:  # avoid out of range code
                shifted_back += chr(ord(char) - shifts)
            except ValueError:
                pass

            shifted_forward += chr(ord(char) + shifts)
        if flag_format in shifted_back:
            echo(line, shifted_back)
            pass
        elif flag_format in shifted_forward:
            echo(line, shifted_forward)
        shifted_back = ""
        shifted_forward = ""


def crack_md5(hash):
    if findall(r"([a-fA-F\d]{32})", hash):  # check if it's MD5 hash
        try:
            result = get(f"https://www.nitrxgen.net/md5db/{hash}").text
            echo(hash, result) if result != '' else None

        except ConnectionError:
            print("Connection Error: Check your internet connectivity")
        finally:
            pass


if __name__ == '__main__':
    args = parse_arguments()
    if args.debug:
        file_name = 'image.png'
        flag_format = 'TUCTF'
    else:
        file_name = args.file_name
        flag_format = args.flag_format

    strings_output = popen(f'strings "{file_name}" | sort | uniq').read()
    print(strings_output) if args.verbose else None
    lines = strings_output.split('\n')

    check_functions = [check_plain_flag,
                       check_binary_flag,
                       check_base16_flag,
                       check_base32_flag,
                       check_base45_flag,
                       check_base64_flag,
                       check_base85_flag,
                       check_base8_flag
                       ]

    for check in check_functions:
        Thread(target=check, args=[lines[:]]).start()

    Thread(target=rotate).start() if not args.no_rot else None

    for shifts in range(2, 26):
        Thread(target=shift, args=[lines[:], shifts]).start() if not args.no_rot else None

    for hash in lines[:]:
        Thread(target=crack_md5, args=[hash]).start()
